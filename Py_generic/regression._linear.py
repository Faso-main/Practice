# Импортируем необходимые библиотеки
import matplotlib.pyplot as plt # Библиотека для создания графиков и визуализации данных
import numpy as np              # Библиотека для работы с числовыми массивами (numpy arrays)
from sklearn.linear_model import LinearRegression # Класс LinearRegression из scikit-learn для выполнения линейной регрессии

# --- Создание данных ---
# Создаем простой набор данных для демонстрации
# X - это наш признак (независимая переменная).
# scikit-learn ожидает, что X будет двумерным массивом (количество_образцов, количество_признаков).
# Мы используем .reshape(-1, 1) для преобразования одномерного массива [1, 2, 3, 4, 5]
# в двумерный [[1], [2], [3], [4], [5]] с 5 строками и 1 столбцом (одним признаком).
X = np.array([1, 2, 3, 4, 5]).reshape(-1, 1)

# y - это наша целевая переменная (зависимая переменная), которую мы хотим предсказать.
# Это одномерный массив, соответствующий значениям в X.
y = np.array([2, 4, 5, 4, 5])

# Переменные после создания:
# X: [[1], [2], [3], [4], [5]] (тип: numpy.ndarray, форма: (5, 1))
# y: [2, 4, 5, 4, 5]           (тип: numpy.ndarray, форма: (5,))

# --- Обучение модели ---
# Создаем экземпляр (объект) модели линейной регрессии.
# Переменная model теперь представляет нашу модель.
model = LinearRegression()

# Обучаем модель на наших данных X и y.
# Метод .fit() находит оптимальные параметры (коэффициент и пересечение)
# для линии y = coef * X + intercept, которые минимизируют сумму квадратов ошибок
# между фактическими значениями y и предсказанными моделью значениями.
# После выполнения fit(), модель "знает" наилучшую прямую для этих данных.
model.fit(X, y)

# --- Предсказания ---
# Делаем предсказания с помощью обученной модели для тех же данных X, на которых она обучалась.
# Это нужно, чтобы получить точки для построения линии регрессии.
# y_pred будет содержать предсказанные моделью значения y для каждого X из обучающего набора.
# Вычисление для каждого X_i: y_pred_i = model.coef_[0] * X_i + model.intercept_
y_pred = model.predict(X)

# Переменная после предсказания:
# y_pred: массив предсказанных значений, например, [2.6, 3.4, 4.2, 5. , 5.8] (точные значения зависят от данных)
#         (тип: numpy.ndarray, форма: (5,))

# --- Вывод коэффициентов модели ---
# После обучения (model.fit()) модель сохраняет найденные параметры в атрибутах с подчеркиванием (_).
# model.coef_ - массив коэффициентов (у нас только один признак, поэтому один коэффициент).
# model.intercept_ - значение пересечения с осью Y (свободный член).
print(f"Коэффициент (угловой коэффициент): {model.coef_[0]}") # model.coef_ сам является массивом, поэтому берем первый элемент
print(f"Пересечение с осью y: {model.intercept_}")

# --- Предсказание для новой точки ---
# Создаем новое значение признака, для которого хотим сделать предсказание (например, X=6).
# Снова используем reshape(-1, 1) для соответствия формату ввода модели.
new_X = np.array([6]).reshape(-1, 1)

# Делаем предсказание для нового значения new_X.
# Вычисление: new_pred[0] = model.coef_[0] * new_X[0] + model.intercept_
new_pred = model.predict(new_X)

# Переменные после предсказания для новой точки:
# new_X:    [[6]] (тип: numpy.ndarray, форма: (1, 1))
# new_pred: [предсказанное_значение_для_6] (тип: numpy.ndarray, форма: (1,))

# Выводим предсказанное значение для X=6.
print(f"Предсказание для X = 6: {new_pred[0]}")

# --- Визуализация результатов ---
# Создаем точечный график для исходных данных (X, y).
plt.scatter(X, y, color='blue', label='Исходные данные')

# Рисуем линию регрессии.
# Она соединяет точки (X, y_pred), где y_pred - это предсказанные значения для исходных X.
# Эта линия представляет модель, найденную линейной регрессией.
plt.plot(X, y_pred, color='red', label='Линия регрессии')

# Добавляем на график точку нового предсказания (new_X, new_pred).
plt.scatter(new_X, new_pred, color='green', label='Новое предсказание')

# Добавляем подписи к осям.
plt.xlabel('X')
plt.ylabel('y')

# Отображаем легенду, чтобы различать точки и линии на графике.
plt.legend()

# Отображаем сам график.
try:
    plt.show()
except KeyboardInterrupt as e:
    print(f'Работа была остановлена......')
except Exception as e:
    print(f'Ошибка вида: {e}')
